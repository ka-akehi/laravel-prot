# 悲観的ロックまとめ

## 分離レベル別のロック戦略と悲観的ロックの実現方法

| 分離レベル                                 | 読み取りの特徴                             | 発生しうる問題                                                       | ロック戦略（InnoDB）                                                        | 使用される手法                                                                              | 悲観的ロックの実現方法                                                                                           |
| ------------------------------------------ | ------------------------------------------ | -------------------------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **READ UNCOMMITTED**                       | 未コミットの変更も読める（ダーティリード） | ダーティリード、ファントムリード                                     | 基本的にロックしない（UPDATE 時にだけ X ロック）                            | 行ロック（更新時のみ）                                                                      | `lockForUpdate` は効くが実験では効果が見えにくい                                                                 |
| **READ COMMITTED**                         | コミット済みのデータのみ読める             | ノンリピータブルリード、ファントムリード                             | 読み取りはロックしない（毎回最新を読む）。UPDATE/DELETE は対象行に X ロック | 行ロック                                                                                    | `lockForUpdate` で更新中行をブロック可能（行単位の悲観的ロック）                                                 |
| **REPEATABLE READ**（InnoDB のデフォルト） | 同じトランザクション内では同じ結果を返す   | ファントムリード（標準 SQL では）、ただし InnoDB は gap ロックで防止 | 行ロック + ギャップロック + ネクストキーロック（範囲をロック）              | 行ロック、ギャップロック、ネクストキーロック、意図ロック、Insert Intention Lock             | `lockForUpdate` により行・範囲ロックを取得できる（行ロック実験、ギャップロック実験、デッドロック実験で確認済み） |
| **SERIALIZABLE**                           | SELECT すら他トランザクションをブロック    | 特になし（最も強い）                                                 | SELECT にも共有ロック（S ロック）、UPDATE/INSERT はブロック                 | 行ロック、ギャップロック、ネクストキーロック、範囲ロック、意図ロック、Insert Intention Lock | `lockForUpdate` が不要。普通の SELECT が悲観的ロックの役割を果たす                                               |

---

## ロック戦略で使用される手法の整理（＋具体例）

1. **行ロック (Record Lock)**

    - 特定の行そのものに対するロック
    - 主キーやユニークインデックス検索でヒットした行にかかる
    - **例**
        ```sql
        SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
        -- id=1 の行に排他ロック
        ```

2. **ギャップロック (Gap Lock)**

    - 既存行と既存行の間の「隙間 (gap)」をロック
    - 新しい行の INSERT を防ぐために利用
    - **例**
        ```sql
        SELECT * FROM accounts WHERE id BETWEEN 1 AND 10 FOR UPDATE;
        -- id=1〜10 の行と、その前後の隙間もロック
        -- → id=5 の INSERT はブロックされる
        ```

3. **ネクストキーロック (Next-Key Lock)**

    - 行ロック + 直後のギャップを同時にロック
    - ファントムリードを防ぐために利用
    - **例**
        ```sql
        SELECT * FROM accounts WHERE id = 10 FOR UPDATE;
        -- id=10 と (10, 次の行) の範囲にロック
        -- → id=10 の更新も、id=11 の INSERT もブロック
        ```

4. **範囲ロック (Range Lock)**

    - `WHERE` 条件で指定した範囲全体にロック
    - 特に **SERIALIZABLE** では SELECT にも適用
    - **例**
        ```sql
        SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
        SELECT * FROM accounts WHERE balance > 100;
        -- balance > 100 の範囲全体がロック
        -- → その範囲に新しい行を INSERT できない
        ```

5. **意図ロック (Intention Lock)**

    - テーブル全体に「これからこのテーブル内で行ロックを取ります」という宣言ロック
    - 実際の行ロックと組み合わせて整合性を維持
    - **例**
        - 内部動作なので直接は指定できないが、
            ```sql
            UPDATE accounts SET balance = balance + 10 WHERE id = 1;
            ```
            を実行すると、内部的に **「accounts テーブルに意図排他ロック (IX)」** がセットされる

6. **Insert Intention Lock（挿入意図ロック）**
    - 複数トランザクションが **同じ gap に INSERT** しようとしたときに使われる特殊ロック
    - 挿入の衝突を効率的に解決する仕組み
    - **例**
        ```sql
        -- T1
        INSERT INTO accounts (id, name, balance) VALUES (101, 'User1', 100);
        -- T2
        INSERT INTO accounts (id, name, balance) VALUES (101, 'User2', 200);
        ```
        → InnoDB が「挿入意図ロック」を管理し、片方をブロック or エラーにする

---

## 学習ポイントまとめ

### 1. READ UNCOMMITTED

-   ロック戦略: 更新のみロック
-   使用手法: 行ロック（更新時）
-   悲観的ロック: `lockForUpdate` は有効だが「ダーティリード確認」がメインの実験

### 2. READ COMMITTED

-   ロック戦略: 読み取りはロックなし、更新対象行のみ X ロック
-   使用手法: 行ロック
-   悲観的ロック: `lockForUpdate` によって行単位のロックを明示できる

### 3. REPEATABLE READ

-   ロック戦略: 行ロック + ギャップロック + ネクストキーロック
-   使用手法: 行ロック、ギャップロック、ネクストキーロック、意図ロック、Insert Intention Lock
-   悲観的ロック: `lockForUpdate` で行や範囲をロック → 行ロック・ギャップロック・デッドロックの観察が可能

### 4. SERIALIZABLE

-   ロック戦略: SELECT すらロックを伴う（共有ロック）
-   使用手法: 行ロック、ギャップロック、ネクストキーロック、範囲ロック、意図ロック、Insert Intention Lock
-   悲観的ロック: SELECT だけで実現可能（lockForUpdate 不要）

---

# 楽観的ロックまとめ

## 基本概念

-   **悲観的ロック**

    -   「他の人が更新するかもしれないから、先にロックしておこう」
    -   → DB が排他制御を行う

-   **楽観的ロック**
    -   「他の人が更新することは少ないだろうから、ロックは取らない」
    -   → 更新時に **競合があれば検出して失敗させる**
    -   DB レベルではなく、**アプリケーションレベルで制御する**

## 実現方法

1. **バージョン番号方式**

    - `version` カラムを用意して更新時に比較する方式
    - 更新成功時に `version` をインクリメント
    - 競合すれば更新件数 0 件となり、失敗として検出できる

2. **更新日時方式**
    - 既存の `updated_at` カラムを利用
    - 更新前に取得した `updated_at` と一致することを条件に UPDATE
    - 不一致なら「他トランザクションで更新済み」と判断

## バージョン方式 vs 更新日時方式

| 項目       | version 方式                 | updated_at 方式                                |
| ---------- | ---------------------------- | ---------------------------------------------- |
| 管理カラム | 数値 (version)               | 更新日時 (updated_at)                          |
| 比較精度   | 確実（一意にインクリメント） | 精度に限界あり（秒未満の競合検出不可の可能性） |
| メリット   | 高精度・確実に検出できる     | 既存のカラムを利用できるので実装が簡単         |
| デメリット | 新規カラム追加が必要         | 秒未満の更新が競合検出できないケースがある     |

## 実験方法

1. **T1（バッチ側）**

    - レコードを取得し、更新待機

2. **T2（Tinker 側）**

    - 同じレコードを取得し、更新実行

3. **観察結果**
    - 先に更新した方が成功
    - 後に更新した方は失敗（競合検出）

## まとめ

-   どちらも「競合発生時に更新失敗する」という挙動を確認済み
-   適用シーンによる使い分け
    -   競合頻度が低い → 楽観的ロックが適切
    -   競合頻度が高い（決済・在庫管理など） → 悲観的ロックが適切
